
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Part 4</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-49751789-4"
                  id="part-4"
                  title="Part 4"
                  environment="web"
                  feedback-link="https://github.com/Scott3142/python-programming">
    
      <google-codelab-step label="Introduction to object-oriented programming" duration="0">
        <h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>You&#39;re familiar with the concepts of class, object, constructor, object methods, and object variables.</li>
<li>You understand that a class defines an object&#39;s methods and that the values of instance (object) variables are object-specific.</li>
<li>You know how to create classes and objects, and know how to use objects in your programs.</li>
</ul>
<p>We&#39;ll now begin our journey in to the world of object-oriented programming. We&#39;ll start with focusing on describing concepts and data using objects. From there on, we&#39;ll learn how to add functionality, i.e., methods to our program.</p>
<p>Object-oriented programming is concerned with isolating concepts of a problem domain into separate entities and then using those entities to solve problems. Concepts related to a problem can only be considered once they&#39;ve been identified. In other words, we can form abstractions from problems that make those problem easier to approach.</p>
<p>Once concepts related to a given problem have been identified, we can also begin to build constructs that represent them them into programs. These constructs, and the individual instances that are formed from them, i.e., objects, are used in solving the problem. The statement &#34;programs are built from small, clear, and cooperative objects&#34; may not make much sense yet. However, it will appear more sensible as we progress through the course, perhaps even self-evident.</p>
<h2 is-upgraded>Classes and Objects</h2>
<p>We&#39;ve already used some of the classes and objects provided by Python. A <strong>class</strong> defines the attributes of objects, i.e., the information related to them (instance variables), and their commands, i.e., their methods. The values of instance (i.e., object) variables define the internal state of an individual object, whereas methods define the functionality it offers.</p>
<p>A <strong>Method</strong> is a piece of source code written inside a class that&#39;s been named and has the ability to be called. A method is always part of some class and is often used to modify the internal state of an object instantiated from a class.</p>
<p>An object is always instantiated by calling a method that created an object.</p>
<aside class="special"><p><strong>The Relationship Between a Class and an Object<br></strong>&gt;br&gt; A class lays out a blueprint for any objects that are instantiated from it. Let&#39;s draw from an analogy from outside the world of computers. Detached houses are most likely familiar to most, and we can safely assume the existence of drawings somewhere that determine what exactly a detached house is to be like. A class is a blueprint. In other words, it specifies what kinds of objects can be instantiated from it. <br><br> Individual objects, detached houses in this case, are all created based on the same blueprints - they&#39;re instances of the same class. The states of individual objects, i.e., their attributes (such as the wall color, the building material of the roof, the color of its foundations, the doors&#39; materials and color, ...) may all vary, however.</p>
</aside>
<aside class="special"><p><strong>Exercise - Your first account<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-1-your-first-account.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Your first bank transfer<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-2-your-first-bank-transfer.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Creating Classes</h2>
<p>A class specifies what the objects instantiated from it are like.</p>
<ul>
<li>The <strong>object&#39;s variables (instance variables)</strong> specify the internal state of the object</li>
<li>The <strong>object&#39;s methods</strong> specify what the object does</li>
</ul>
<p>We&#39;ll now familiarize ourselves with creating our own classes and defining the variable that belong to them.</p>
<p>A class is defined to represent some meaningful entity, where a &#34;meaningful entity&#34; often refers to a real-world object or concept. If a computer program had to process personal information, it would perhaps be meaningful to define a separate class <code>Person</code> consisting of methods and attributes related to an individual.</p>
<p>Let&#39;s begin. We&#39;ll assume that we have a project template that has an empty main program:</p>
<pre><code>class Main:

    def __init__(self):
        # some code
</code></pre>
<p>Let&#39;s create a class named <code>Person</code>. For this class, we create a separate file named <code>Person.py</code>. Our program now consists of two separate files since the main program is also in its own file. The <code>Person.py</code> file initially contains the class definition <strong>class Person</strong> and the block that confines the contents of the class.</p>
<pre><code>class Person:

</code></pre>
<p>A class defines the attributes and behaviours of objects that are created from it. Let&#39;s decide that each person object has a name and an age. It&#39;s natural to represent the name as a string, and the age as an integer. We&#39;ll go ahead and add these to our blueprint:</p>
<pre><code>class Person:
    name = &#34;&#34;
    age = 0
</code></pre>
<p>We specify above that each object created from the <code>Person</code> class has a <code>name</code> and an <code>age</code>. Variables defined inside a class are called <strong>instance variables</strong>, or object fields or object attributes. Other names also seem to exist.</p>
<p>Instance variables are written on the lines following the class definition <code>class Person:</code>. Many programming languages such as Java has a concept of <strong>encapsulation</strong>, which allows <strong>private</strong> variables to be &#34;hidden&#34; inside the object. In Python, there is no existence of &#34;Private&#34; instance variables so we do not discuss them further here.</p>
<p>We have now defined a blueprint – a class – for the person object. Each new person object has the variables <code>name</code> and <code>age</code>, which are able to hold object-specific values. The &#34;state&#34; of a person consists of the values assigned to their name and age.</p>
<aside class="special"><p><strong>Exercise - Dog attributes<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-3-dog-attributes.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Defining a Constructor</h2>
<p>We want to set an initial state for an object that&#39;s created. It&#39;d be convenient to pass values ​​to the variables of that object as it&#39;s being created. For example, when creating a new person object, it&#39;s useful to be able to provide it with a name:</p>
<pre><code>def main(Person):
    ada = Person(&#34;Ada&#34;)
    # ...
</code></pre>
<p>This is achieved by defining the method that creates the object, i.e., its constructor. The constructor is defined after the instance variables. In the following example, a constructor is defined for the Person class, which can be used to create a new Person object. The constructor sets the age of the object being created to 0, and the string passed to the constructor as a parameter as its name:</p>
<pre><code>class Person:
    name = &#34;&#34;
    age = 0

    def __init__(self,initialName):
        self.age = 0
        self.name = initialName
</code></pre>
<p>The constructor is provided, as a parameter, to the name of the person object to be created. The parameter is enclosed in parentheses and follows the constructor&#39;s name. The parentheses that contain optional parameters are followed by curly brackets. In between these brackets is the source code that the program executes when the constructor is called (e.g., <code>Person (&#34;Ada&#34;)</code>).</p>
<p>Objects are always created using a constructor.</p>
<p>A few things to note: the constructor contains the expression <code>self.age = 0</code>. This expression sets the instance variable <code>age</code> of the newly created object (i.e., &#34;self&#34; object&#39;s age) to 0. The second expression <code>self.name = initialName</code> likewise assigns the string passed as a parameter to the instance variable <code>name</code> of the object created.</p>
<aside class="special"><p><strong>Exercise - Room<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-4-room.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Default Constructor<br><br></strong> If the programmer does not define a constructor for a class, Java automatically creates a default one for it. A default constructor is a constructor that doesn&#39;t do anything apart from creating the object. The object&#39;s variables remain uninitialized (generally, the value of any object references will be <code>null</code>, meaning that they do not point to anything, and the values of primitives will be <code>0</code>) <br><br></p>
</aside>
<h2 is-upgraded>Defining Methods For an Object</h2>
<p>We know how to create an object and initialize its variables. However, an object also needs methods to be able to do anything. As we&#39;ve learned, a <strong>method</strong> is a named section of source code inside a class which can be invoked.</p>
<pre><code>class Person:
    name = &#34;&#34;
    age = 0

    def __init__(self,initialName):
        self.age = 0
        self.name = initialName

    def printPerson(self):
        print(self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;)
</code></pre>
<p>A method is written inside of the class beneath the constructor. The method name is preceded by <code>def</code>, just like a function. The only difference between a function and a method is that a method is tied to an object, as we&#39;ve seen.</p>
<p>The method <code>printPerson</code> contains one line of code that makes use of the instance variables <code>name</code> and <code>age</code>.. Instance variables are referred to with the prefix <code>this</code>. All of the object&#39;s variables are visible and available from within the method.</p>
<p>Let&#39;s create three persons in the main program and request them to print themselves:</p>
<pre><code>def main():
    ada = Person(&#34;Ada&#34;)
    alan = Person(&#34;Alan&#34;)
    grace = Person(&#34;Grace&#34;)

    ada.printPerson()
    alan.printPerson()
    grace.printPerson()

main()
</code></pre>
<p>Prints:</p>
<aside class="warning"><p>Ada, age 0 years <br> Alan, age 0 years <br> Grace, age 0 years</p>
</aside>
<aside class="special"><p><strong>Exercise - Whistle<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-5-whistle.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Door<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-6-door.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Product<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-7-product.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Changing an Instance Variable&#39;s Value in a Method</h2>
<p>Let&#39;s add a method to the previously created person class that increments the age of the person by a year.</p>
<pre><code>class Person:
    def __init__(self,initialName):
        self.age = 0
        self.name = initialName

    def printPerson(self):
        print(self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;)

    def growOlder(self):
        self.age = self.age + 1
</code></pre>
<p>The method is written inside the <code>Person</code> class just as the <code>printPerson</code> method was. The method increments the value of the instance variable <code>age</code> by one.</p>
<p>Let&#39;s call the method and see what happens:</p>
<pre><code>def main():
    ada = Person(&#34;Ada&#34;)
    alan = Person(&#34;Alan&#34;)
    grace = Person(&#34;Grace&#34;)

    ada.printPerson()
    alan.printPerson()
    grace.printPerson()

    ada.growOlder()
    alan.growOlder()

    ada.printPerson()
    alan.printPerson()

main()
</code></pre>
<p>Prints:</p>
<aside class="warning"><p>Ada, age 0 years <br> Alan, age 0 years <br> Grace, age 0 years <br> Ada, age 1 years <br> Alan, age 1 years <br></p>
</aside>
<p>That is to say that when the two objects are &#34;born&#34; they&#39;re both zero-years old (<code>self.age = 0</code> is executed in the constructor). The <code>ada</code> object&#39;s <code>growOlder</code> method is called twice. As the print output demonstrates, the age of Ada is 2 years after growing older. Calling the method on an object corresponding to Ada has no impact on the age of the other person object since each object instantiated form a class has its own instance variables.</p>
<p>The method can also contain conditional statements and loops. The growOlder method below limits aging to 30 years.</p>
<pre><code>class Person:
    def __init__(self,initialName):
        self.age = 0
        self.name = initialName

    def printPerson(self):
        print(self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;)

    def growOlder(self):
        if (self.age &lt; 30):
            self.age = self.age + 1
</code></pre>
<aside class="special"><p><strong>Exercise - Decreasing Counter<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-8-decreasing-counter.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Debt<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-9-debt.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Returning a Value From a Method</h2>
<p>A method can return a value. The methods we&#39;ve created in our objects haven&#39;t so far returned anything. This has been marked by the lac of a <code>return</code> statement in the method body.</p>
<pre><code>class Door:
    def knock(self):
        # ...
        return #something
</code></pre>
<p>If we want the method to return a value, we need to insert a <code>return</code> keyword. In the following example, the Teacher class has a  method <code>grade</code> that always returns a variable (in this case, the value 10):</p>
<pre><code>class Teacher:
    def grade(self):
        return 10
</code></pre>
<p>The method above returns a variable of value 10 when called. For the return value to be used, it needs to be assigned. This happens the same way as regular variable assignment, i.e., by using the equals sign:</p>
<pre><code>def main():
    teacher = Teacher()

    grading = teacher.grade()

    print(&#34;The grade received is &#34; + str(grading))
</code></pre>
<aside class="warning"><p>The grade received is 10</p>
</aside>
<p>The return value could also be used to form part of an expression.</p>
<pre><code>def main():
    first = Teacher()
    second = Teacher()
    third = Teacher()

    average = (first.grade() + second.grade() + third.grade()) / 3.0

    print(&#34;Grading average &#34; + str(average))
</code></pre>
<aside class="warning"><p>Grading average 10.0</p>
</aside>
<p>Let&#39;s continue with the Person class and add a <code>returnAge</code> method that returns the person&#39;s age.</p>
<pre><code>class Person:
    def __init__(self,initialName):
        self.age = 0
        self.name = initialName

    def printPerson(self):
        print(self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;)

    def growOlder(self):
        self.age = self.age + 1

    # the added method
    def returnAge(self):
        return self.age

</code></pre>
<p>Let&#39;s illustrate how the method works:</p>
<pre><code>def main():
    grace = Person(&#34;Grace&#34;)
    alan = Person(&#34;Alan&#34;)

    grace.growOlder()
    grace.growOlder()

    alan.growOlder()

    print(&#34;Grace&#39;s age: &#34; + str(grace.returnAge()))
    print(&#34;Alan&#39;s age: &#34; + str(alan.returnAge()))
    combined = grace.returnAge() + alan.returnAge()

    print(&#34;Grace&#39;s and Alan&#39;s combined age &#34; + str(combined) + &#34; years&#34;)
</code></pre>
<aside class="warning"><p>Grace&#39;s age 2 <br> Alan&#39;s age 1 <br><br> Grace&#39;s and Alan&#39;s combined age 3 years</p>
</aside>
<aside class="special"><p><strong>Exercise - Song<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-10-song.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Film<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-11-film.git" target="_blank">Source files on Github</a></p>
</aside>
<p>As we came to notice, methods can contain source code in the same way as other parts of our program. Methods can have conditionals or loops, and other methods can also be called from them.</p>
<p>Let&#39;s now write a method for the person that determines if the person is of legal age. The method returns a boolean - either <code>True</code> or <code>False</code>:</p>
<pre><code>class Person:

    def isOfLegalAge(self):
        if (self.age &lt; 18):
            return False

        return True

    # The method could have been written more succintly in the following way:
    #
    # def isOfLegalAge():
    #    return self.age &gt;= 18
</code></pre>
<p>And let&#39;s test it out:</p>
<pre><code>def main():
    grace = Person(&#34;Grace&#34;)
    alan = Person(&#34;Alan&#34;)

    i = 0
    while (i &lt; 30):
        grace.growOlder()
        i = i + 1

    alan.growOlder()

    if (alan.isOfLegalAge()):
        print(&#34;of legal age: &#34;)
        alan.printPerson()
    else:
        print(&#34;underage: &#34;)
        alan.printPerson()

    if (grace.isOfLegalAge()):
        print(&#34;of legal age: &#34;)
        grace.printPerson()
    else:
        print(&#34;underage: &#34;)
        grace.printPerson()
</code></pre>
<aside class="warning"><p>underage: Alan, age 1 years <br> of legal age: Grace, age 30 years</p>
</aside>
<p>Let&#39;s fine-tune the solution a bit more. In its current form, a person can only be &#34;printed&#34; in a way that includes both the name and the age. Situations exist, however, where we may only want to know the name of an object. Let&#39;s write a separate method for this use case:</p>
<pre><code>class Person:
    # ...

    def getName(self):
        return self.name
</code></pre>
<p>The <code>getName</code> method returns the instance variable <code>name</code> to the caller. The name of this method is somewhat strange. It is the usual convention to name a method that returns an instance variable exactly this way, i.e., <code>getVariableName</code>. Such methods are often referred to as &#34;getters&#34;.</p>
<p>Let&#39;s mould the main program to use the new &#34;getter&#34; method:</p>
<pre><code>def main():
    grace = Person(&#34;Grace&#34;)
    alan = Person(&#34;Alan&#34;)

    i = 0
    while (i &lt; 30):
        grace.growOlder()
        i = i + 1

    alan.growOlder()

    if (alan.isOfLegalAge()):
         print(alan.getName() + &#34; is of legal age&#34;)
    else:
         print(alan.getName() + &#34; is underage&#34;)

    if (grace.isOfLegalAge()):
         print(grace.getName() + &#34; is of legal age&#34;)
    else:
         print(grace.getName() + &#34; is underage &#34;)
</code></pre>
<p>The print output is starting to turn out quit neat:</p>
<aside class="warning"><p>Alan is underage <br> Grace is of legal age</p>
</aside>
<aside class="special"><p><strong>Exercise - Gauge<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-12-gauge.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>A string representation of an object and the <strong>str</strong>-method</h2>
<p>We are guilty of programming in a somewhat poor style by creating a method for printing the object, i.e., the <code>printPerson</code> method. A preferred way is to define a method for the object that returns a &#34;string representation&#34; of the object. We can call the method returning the string representation <code>__str__</code>. Let&#39;s define this method for the person in the following example:</p>
<p>The <code>__str__</code> functions as <code>printPerson</code> does. However, it doesn&#39;t itself print anything but instead returns a string representation, which the calling method can execute for printing as needed.</p>
<p>The method is used in a somewhat surprising way:</p>
<pre><code>class Person:
    # ...

    def __str__(self):
        return self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;
</code></pre>
<pre><code>def main():
    grace = Person(&#34;Grace&#34;)
    alan = Person(&#34;Alan&#34;)

    i = 0
    while (i &lt; 30):
        grace.growOlder()
        i = i + 1

    alan.growOlder()

    print(grace)
    print(alan)
</code></pre>
<p>In principle, the <code>print</code> method requests the object&#39;s string representation and prints it. The call to the <code>__str__</code> method returning the string representation does not have to be written explicitly, as Python adds it automatically.</p>
<aside class="special"><p><strong>Exercise - Agent<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-13-agent.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Method parameters</h2>
<p>Let&#39;s continue with the <code>Person</code> class once more. We&#39;ve decided that we want to calculate people&#39;s body mass indexes. To do this, we write methods for the person to set both the height and the weight, and also a method to calculate the body mass index. The new and changed parts of the Person object are as follows:</p>
<pre><code>class Person:

    def Person(self,initialName):
        self.age = 0
        self.weight = 0
        self.height = 0
        self.name = initialName

    def setHeight(self,newHeight):
        self.height = newHeight

    def setWeight(self,newWeight):
        self.weight = newWeight

    def bodyMassIndex(self):
        heightPerHundred = self.height / 100.0
        return self.weight / (heightPerHundred * heightPerHundred)

    # ...
</code></pre>
<p>The instance variables <code>height</code> and <code>weight</code> were added to the person. Values for these can be set using the <code>setHeight</code> and <code>setWeight</code> methods. Java&#39;s standard naming convention is used once again, that is, if the method&#39;s only purpose is to set a value to an instance variable, then it&#39;s named as <code>setVariableName</code>. Value-setting methods are often called &#34;setters&#34;. The new methods are put to use in the following case:</p>
<pre><code>def main():
    grace = Person(&#34;Grace&#34;)
    ada = Person(&#34;Ada&#34;)

    grace.setHeight(180)
    grace.setWeight(86)

    ada.setHeight(175)
    ada.setWeight(64)

    print(grace.getName() + &#34;, body mass index is &#34; + str(grace.bodyMassIndex()))
    print(ada.getName() + &#34;, body mass index is &#34; + str(ada.bodyMassIndex()))
}
</code></pre>
<p>Prints:</p>
<aside class="warning"><p>Grace, body mass index is 26.54320987654321 <br> Ada, body mass index is 20.897959183673468</p>
</aside>
<h2 is-upgraded>A parameter and instance variable having the same name!</h2>
<p>In the preceding example, the <code>setHeight</code> method sets the value of the parameter <code>newHeight</code> to the instance variable <code>height</code>:</p>
<pre><code>def setHeight(self,newHeight):
    self.height = newHeight
</code></pre>
<p>The parameter&#39;s name could also be the same as the instance variable&#39;s, so the following would also work:</p>
<pre><code>def setHeight(self,height):
    self.height = height
</code></pre>
<p>In this case, <code>height</code> in the method refers specifically to a parameter named <em>height</em> and <code>self.height</code> to an instance variable of the same name. For example, the following example would not work as the code does not refer to the instance variable <em>height</em> at all. What the code does in effect is set the <code>height</code> variable received as a parameter to the value it already contains:</p>
<pre><code>def setHeight(self,height):
    # DON&#39;T DO THIS!!!
    height = height
</code></pre>
<pre><code>def setHeight(self,height):
    # DO THIS INSTEAD!!!
    self.height = height
</code></pre>
<aside class="special"><p><strong>Exercise - Multiplier<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-14-mutiplier.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Calling an internal method</h2>
<p>The object may also call its methods. For example, if we wanted the string representation returned by <strong>str</strong> to also tell of a person&#39;s body mass index, the object&#39;s own <code>bodyMassIndex</code> method should be called in the <code>__str__</code> method:</p>
<pre><code>def __str__():
    return self.name + &#34;, age &#34; + str(self.age) + &#34; years, my body mass index is &#34; + str(self.bodyMassIndex())
}
</code></pre>
<p>So, when an object calls an internal method, the name of the method and this prefix suffice.</p>
<aside class="special"><p><strong>Exercise - Statistics<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-15-statistics.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Payment Card<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-16-payment-card.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Rounding errors<br><br></strong> You probably noticed that some of the figures have rounding errors. In the previous exercise, for example, Grace&#39;s balance of 30.7 may be printed as <code>30.700000000000003</code>. This is because floating-point numbers, such as <code>double</code>, are actually stored in binary form. That is, in zeros and ones using only a limited number of numbers. <br><br> As the number of floating-point numbers is infinite – (in case you&#39;re wondering &#34;how infinite?&#34;, think how many floating-point or decimal values fit between the numbers 5 and 6 for instance). All of the floating-point numbers simply cannot be represented by a finite number of zeros and ones. Thus, the computer must place a limit on the accuracy of stored numbers. <br><br> Normally, account balances, for instance, are saved as integers such that, say, the value 1 represents one cent.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Objects in a list" duration="0">
        <h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>You can add objects to a list</li>
<li>You can go through objects in a list</li>
</ul>
<p>In the example below we first add strings to a list, after which the strings in the list are printed one by one.</p>
<pre><code># initialise list
names = []

# string can first be stored in a variable
name = &#34;Betty Jennings&#34;
# then add it to the list
names.append(name)

# strings can also be directly added to the list:
names.append(&#34;Betty Snyder&#34;)
names.append(&#34;Frances Spence&#34;)
names.append(&#34;Kay McNulty&#34;)
names.append(&#34;Marlyn Wescoff&#34;)
names.append(&#34;Ruth Lichterman&#34;)

# several different repeat statements can be
# used to go through the list elements

# 1. while loop
index = 0
while (index &lt; len(names)):
    print(names[index])
    index = index + 1

print()

# 2. for loop with index
for i in range(len(names)):
    print(names[i])

print()

# 3. for each loop (no index)
for name in names:
    print(name)
</code></pre>
<aside class="warning"><p>Betty Jennings <br> Betty Snyder <br> Frances Spence <br> Kay McNulty <br> Marlyn Wescoff <br> Ruth Lichterman <br><br> Betty Jennings <br> Betty Snyder <br> Frances Spence <br> Kay McNulty <br> Marlyn Wescoff <br> Ruth Lichterman <br><br> Betty Jennings <br> Betty Snyder <br> Frances Spence <br> Kay McNulty <br> Marlyn Wescoff <br> Ruth Lichterman</p>
</aside>
<h2 is-upgraded>Adding object to a list</h2>
<p>Strings are objects, so it should come as no surprise that other kinds of objects can also be found in lists. Next, let&#39;s examine the cooperation of lists and objects in more detail.</p>
<p>Let&#39;s assume we have access to the class defined below, describing a person.</p>
<pre><code>class Person:
    def __init__(self,name):
        self.age = 0
        self.name = name
        self.weight = 0
        self.height = 0

    def getName(self):
        return self.name

    def getAge(self):
        return self.age

    def growOlder(self):
        self.age = self.age + 1

    def isOfLegalAge(self):
        if (self.age &lt; 18):
            return False

        return True

    def setHeight(self,newHeight):
        self.height = newHeight

    def setWeight(self,newWeight):
        self.weight = newWeight

    def bodyMassIndex(self):
        heightPerHundred = self.height / 100.0
        return self.weight / (heightPerHundred * heightPerHundred)

    def __str__(self):
        return self.name + &#34;, age &#34; + str(self.age) + &#34; years&#34;

</code></pre>
<p>Handling objects in a list is not really different in any way from the previous experience we have with lists. The essential difference is only to define the type for the stored elements when you create the list.</p>
<p>In the example below we first create a list meant for storing Person type object, after which we add persons to it. Finally the person objects are printed one by one.</p>
<pre><code>persons = []

# a person object can be created first
john = Person(&#34;John&#34;)

# and then added to the list
persons.append(john)

# person objects can also be created &#34;in the same sentence&#34; that they are added to the list
persons.append(Person(&#34;Matthew&#34;))
persons.append(Person(&#34;Martin&#34;))

for person in persons:
    print(person)
</code></pre>
<aside class="warning"><p>John, age 0 years <br> Matthew, age 0 years <br> Martin, age 0 years</p>
</aside>
<h2 is-upgraded>Adding user-inputted objects to a list</h2>
<p>The structure we used earlier for reading inputs is still very useful.</p>
<pre><code>persons = []

# Read the names of persons from the user
while (True):
    name = input(&#34;Enter a name, empty will stop: &#34;)
    if not name: # nice way of checking if a list is empty
        break

    # Add to the list a new person
    # whose name is the previous user input
    persons.append(Person(name))

# Print the number of the entered persons, and their individual information
print()
print(&#34;Persons in total: &#34; + str(len(persons)))
print(&#34;Persons: &#34;)

for person in persons:
    print(person)
</code></pre>
<aside class="warning"><p>Enter a name, empty will stop: <br><em>User: &lt;Ada&gt;<br></em> Enter a name, empty will stop: <em>User: &lt;Grace&gt;<br></em> Enter a name, empty will stop: <em>User: &lt;Katherine&gt;<br><br></em> Persons in total: 3 <br> Persons: <br> Ada, age 0 years <br> Grace, age 0 years <br> Katherine, age 0 years</p>
</aside>
<aside class="special"><p><strong>Exercise - Items<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-17-items.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Multiple constructor parameters</h2>
<p>If the constructor demands more than one parameter, you can query the user for more information. Let&#39;s assume we have the following constructor for the class <code>Person</code>.</p>
<pre><code>class Person:
    def __init__(self,name,age):
        self.age = age
        self.name = name
        self.weight = 0
        self.height = 0

    # ...
</code></pre>
<p>In this case, an object is created by calling the two-parameter constructor.</p>
<p>If we want to query the user for this kind of object, they must be asked for each parameter separately. In the example below, name and age parameters are asked separately from the user. Entering an empty name will end the reading part.</p>
<p>The persons are printed after they have been read.</p>
<pre><code>persons = []

# Read person information from the user
while (True):
    name = input(&#34;Enter name, empty will end: &#34;)
    if not name:
        break

    print(&#34;Enter the age of the person &#34; + name + &#34;: &#34;)

    age = int(input(&#34;Enter the age of the person &#34; + name + &#34;: &#34;))

    # We add a new person to the list.
    # The person&#39;s name and age were decided by the user
    persons.append(Person(name, age))

# We&#39;ll print the number of the inputted persons, and the persons themselves
print()
print(&#34;Total number of persons: &#34; + str(len(persons)))
print(&#34;Persons: &#34;)

for person in persons:
    print(person)
</code></pre>
<aside class="warning"><p>Enter name, empty will end: <br><em>User: &lt;Grace Hopper&gt;<br></em> Enter the age of the person Grace Hopper: <br><em>User: &lt;85&gt;<br></em> Enter name, empty will end: <br><br> Total number of persons: 1 <br> Persons: <br> Grace Hopper, age 85 years</p>
</aside>
<aside class="special"><p><strong>Exercise - Personal Information<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-18-personal-information.git" target="_blank">Source files on Github</a></p>
</aside>
<h2 is-upgraded>Reading input in a specific format</h2>
<p>In the example and exercise below, the required information was entered line by line. By no means is it impossible to ask for input in a specific format, e.g. separated by a comma.</p>
<p>If the name and age were separated by a comma, the program could work in the following manner.</p>
<pre><code>persons = []

# Read person information from the user
print(&#34;Enter the person details separated by a comma, e.g.: Randall,2&#34;)
while (True):
    details = input(&#34;Enter the details, empty will stop: &#34;)
    if not details:
        break

    parts = details.split(&#34;,&#34;)
    name = parts[0]
    age = int(parts[1])
    persons.append(Person(name, age))

# Print the number of the entered persons, and the persons themselves
print()
print(&#34;Total number of persons: &#34; + str(len(persons)))
print(&#34;Persons: &#34;)

for person in persons:
    print(person)
</code></pre>
<h2 is-upgraded>Filtered printing from the list</h2>
<p>You can also examine the objects on the list as you go through it. In the example below, we first ask the user for an age restriction, after which we print all the objects whose age is at least the number given by the user.</p>
<pre><code># Assume we have a &#39;persons&#39; list
# that consists of person objects

ageLimit = int(input(&#34;What is the age limit? &#34;))

for person in persons:
    if (person.getAge() &gt;= ageLimit):
        print(person)
</code></pre>
<aside class="special"><p><strong>Exercise - Television Programs<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-19-television-programs.git" target="_blank">Source files on Github</a></p>
</aside>
<aside class="special"><p><strong>Exercise - Books<br><br></strong> Read the instructions for the exercise and commit the solution via Github. <br><br><a href="https://github.com/btec-diploma-unit4-programming-master/exercise-4-20-books.git" target="_blank">Source files on Github</a></p>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="../../elements/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
